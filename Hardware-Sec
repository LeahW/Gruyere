Overview of potential Hardware vulnerabilities
Hardware Backdoors: Unspecified Don't Care conditions can create opportunities for unintentional or intentional (via foreign IP, 
  untrusted design tools, overseas foundries, unethical hardware engineers, or external compromise) access to restricted states.
  These can be avoided by specifying ever possible state, but creates overhead
Physical Security:
Side Channel Analysis:

Watermarking: Provide proof of authorship by embedding additional signature information. This can be done for Hardware IP by
   creating additional constraints out of Don't Care conditions that encode 0 or 1 bits. Challenge is to ensure equal performance
   (don't increase number of literals) while satisfying both the constraints required by system and by watermark signature.
   Public watermarks use a public signature, which helps transparency, but makes it too easy to change a few bits in the public
   watermark header. To properly validate, hash the bitstream file for the public signature and use this as the key to encrypt
   the hash and match to the public watermark body.
   
Integrated Circuit Metering: Security protocols that protect design house against (overseas) foundries overbuilding orders.
   Passive, non-functional example is imprinted and/or stickered PIN or serial number. 
   
Internal Unclonable Metering example: A functional scheme might use intrinsic variations that arise during the manufacturing process as an identifier. Additional flip-flops are introduced and used to 
   boost the Finite State Machine. This random value can be directed by a design house-controlled input sequence to reach the
   necessary initial state for functionality.
   
External Unclonable Active Metering example: A functional scheme might use additional control signals/logic (e.g. unneeded XOR)
   in non-critical parts of design. Each fabricate circuit is locked until it receives key from design house to unlock correct
   value for all control signals. 
   
Hardware Physical Attack: requires access to chip or connection to signal wires / ability to measure target's signals, e.g.
    acoustic, RFID, and near-field communication, in addition to hardware, cryptographic algorithms, and data analysis
    Attacks are two-phased: Interaction (exploit a physical characteristic) and Exploitation (analyze the collected info)
    
Attackers:
  Class 1: Clever Outsiders. Smart, but limited access to system and limited access to equipment and tools
  Class 2: Knowledgeable Insiders. Has knowledge of system and access to equipment/tools.
  Class 3: Funded Organizations. Access to all resources, team of experts. Can invent new attacks to break target system.
  
Attack Goals:
  Theft of services provided by target, access to resources, or money/payment info from target.
  Illegally Sell or Re-sell the product (IP piracy, overbuilding, cloning, counterfeiting)
  Interrupt or Denial-of-Service (give competitors an unfair edge)
  
  Attackers 'break' the system by gaining info they should not have (secret data or keys, system/chip/IP design info)
   this differs from cryptanalysis in method: not a mathematical analysis of theoretical weakness, but a physical attack
   that targets implementation of cryptographic encryptions. 
   
Attack Types: 
  Invasive Attacks: Direct access needed to chip/device. Hardware often damaged, so attack cannot be repeated and evidence of 
    tampering is often left behind. Typically high cost attack with advanced skill required.
  Non-invasive Attacks: Interact with device/chip via interface (voltage, current, clock, i/o, etc.) passive monitoring or
    active injection. Typically non-damaging, no evidence of tampering, and is low-cost and repeatable.
  Semi-invasive Attacks: Access to surface of the chip, but no contacts with internal wires. Normally does not damage
    equipment and may or may not leave tamper evidence. Moderate cost and skill required. Usually repeatable.
  
  Reverse Engineering: Invasive. Study chip structure and determin functionality by taking apart. Requires high cost,
    skill set similar to hardware designer, and capability similar to hardware manufacturer. 
  Micro-probing: Invasive. Requires direct access to chip surface to observe, manipulate, and interfere.
  Fault Generation: Semi- or Non-invasive. Run hardware in abnormal environments or use faulty input in hopes of causing 
    hardware to leak information or allow additional access.
  Side-channel Attack: Non-invasive. First, monitor/measure chip characteristics (power, current, timing, EM radiation, etc.)
    during normal operation. Second, perform data analysis to learn information.
  Software Attack: Non-invasive. Attacker uses normal input/output interface to exploit vulnerabilities in protocols, 
    algorithms, and software implementations. Repeatable. 
  Decapsulation/Deprocessing: Removing chip package, including multiple layers to expose silicon die and allow attackers to
    reverse engineer using optical microscope, digital camera to capture details of chip design and function at each layer.
  Depassivation/Microprobing: Expensive, high-tech equipment required. Can monitor on-chip bus activities down to the 
    submicron level without disturbing chip activities. Can also inject test signals and observe chip response. Secret keys
    and sensitive data can be extracted from memory using this method.
  Chip modification: Using design knowledge and silicon fabrication capabilities, attackers can rebuild or modify chip for 
    invasive attack, e.g. cutting internal connections to disable on-chip components such as encryption blocks. Cost varies.
  
Attack Tools:
  Invasive: Integrated Circuit soldering/desoldering station, simple chemical lab, high-res optical microscope, oscilloscope,
    logic analyser, signal generator, wire-bonding machine, laser-cutting system, microprobing station, scanning electron 
    microscope, FIB (focused ion beam) station.  Allows depacking of silicon chip and to make contacts with signals.
  Semi-invasive: all of above thru signal generator, plus UV light sources, lasers, microscopes for laser scanning and
    infrared, PC with data acqusition board, FPGA boards, prototyping boards.
  Non-invasive: Integrated Circuit soldering/desoldering station,oscilloscope, logic analyser, signal generator, PC with
    data acqusition board, FPGA boards, prototyping boards, digitial multimeter, Universal Programmer, IC tester,  and
    programmer power supplies
    
Examples:
  Imaging attack: With the help of cameras and photon probing, can read layout of chip, localize active regions and read 
    logical states of transistors. 
  Fault Injections: After locating security fuses, attacker uses UV light to reset fuses to unprotected state. 
  Optical Fault Injection: Illumination of transistor can make it conduct and introduce transient fault or set value of a
    single bit in memory. Can be done with cheap laser pointers.
  Local Heating: Can permanently change memory cells
  Laser Pointers: Write into Static RAM or Memory Masking: disable Write operation in embedded fresh memory
  Side Channel Analysis: Laser can be pointed to certain transistor to collect power trace before and after using laser.
  Brute Force Attack: Search for info such as key/password info on chip, which may be restricted to certain areas of chip or
    memory location can be predicted. Can also try to rebuild truth table of i/o to reveal design details. Applying high
    voltage (twice the normal) or injecting random signals/commands can allow attacker access to factory back doors and test
    mode.
  Data Remanence:
    In SRAM: SRAM retains data for short amount of time after power-down. It also may burn-in data that has been stored 
      long-term and this can be seen after power-up. Finally, data in SRAM can be frozen at low temperatures (less than 20 
      degrees Celsius is typical) and read by attacker.
    In EEPROM and Flash memory devices: Threshold voltage changes after each write/erase cycle in such a way that you can 
      extract data after multiple write/erase cycles.
  Fault Injection: Provide faulty, unexpected input or commands and observe how system executes it. Standard I/O usually has
      safeguards against this, so alternate methods can be used: glitches (e.g. clock, voltage), temperature, white light,
      laser, x-ray and ion beams, electromagnetic flux. Many of these methods can change state of flip-flops/transistors. 
  Glitches: A fast change in the chip's supply signals (e.g. clock, power on/off) whcih can trigger change of state in transistors
      or flip-flops. May not have control of which specific flip-flop or transistor changes, so must do systematic search.

Countermeasures: Use fault-tolerant development techniques. Comes with increased overhead and loss of performance. 
  Software level: execution redundancy, checksums on data transfers, randomized execution, 
  Hardware level: redundancy (i.e. fault tolerance), fault detector
  
  Bus Scrambling: Data and Memory bus lines are usually ordered sequentially from lowest to highest bridge (oor vice versa)
    but you can change the order and connections to make attacker probes more difficult.
  Data Encryption: Encrypt and Ddecrypt data in a trusted zone before use.
  Glue Logic Design: Standard building blocks, e.g. register files, instruction decoders, input/output circuits, arthmetic
    and logical units, are glued together to conceal where the attacker can find targeted signal to attack.
  Sensor Mesh as top inner layer: Monitors all paths continuously, and will short-circuit and trigger an alarm if micro
    probing detected. It then resets memory to preserve data.
    
Tamper Resistance Levels: From lowest to highest in terms of time, cost, and knowledge required to successfully attack:
    Zero: No security features and open access, e.g. microcontrollers, FPGA chips with external memory. No special tools or
          equipment needed to attack. Attack within minutes to hours.
    Low: Some easy to break security features, e.g. microcontroller with unprotected internal memory and propritary access
         Low cost tools needed, $500 or less. Attacks take hours to days.
    MODL: Has security features against low-cost attacks, e.g. microcontroller with memory and access protection, but 
         vulnerable to power analysis or power glitches. Tools needed are $5000 or less and attacks take days to weeks.
    MOD: Has more features to prevent attacks, e.g. microcontroller with protection against UV light attack, ASICs, secure
         memory chips, smartcards. Need special tools, knowledge, equipment up to $100k. Attacks take weeks to months.
    MODH: Application specific security features, e.g. secure FPGA, modern smartcard, complex ASICs    
    HIGH: Systems designed for security applications, e.g. military, banking, etc. Should be secure against all known
         attacks. 
    
FIPS or Federal Information Processing Standards for securing Cryptographic modules: 
  Level 1: Specifies basic security requirements for cryptographic module
  Level 2: Add physical security, e.g. tamper-evident coating and seals, pick-resistant locks
  Level 3: Advanced physical security for cryptographic parameters within cryptographic modules
  Level 4: Detect penetrations to the cryptographic module/device from all directions
  
If the cost to break into system is higher than benefit received, rational attackers won't even try.
Locate overall weak points, but recognize which assets on system are most important to be secured.
Chip manufacturers sell on strong points, but you may need to redesign if you want to fix weaknesses. Many products with
  defects available in the market. Must take system engineering approach and truly design for security, not add in later
  
Modular Exponentiation:
  Modular calculates the remainder when a base integer raised to a given exponent value is divided by a positive integer.
               5^2≡1 (mod 3)  or '5 to the 2nd power is congruent to 1 modulo 3'
  Iterative exponentiation and modular:
     Since 'x≡y (mod n)' is the same as 'ax≡ay (mod n)' you only really need to calculate each exponent when result is less
    than n, otherwise calculate modular of that number and n to keep the exponent number from getting too big.
    
Diffie-Hellman Key Exchange:
  Alice can generate a random number, and keep it a secret, but use it as an exponent value for a set base and calculate using 
  given modular. She gives this result to Bob, who generates a random number, uses same exponent-modular function and gives 
  resulting value to Alice. Alice and Bob's random numbers are hidden from each other but the modular used by each is the same.
  To obtain the key, take Bob's result value and raise it to the value of Alice's secret value and calculate to given modular
  and it will matach Alice's result-raised to-Bob's secret exponent modular exponentiation result.
  
RSA Public Key Encryption:
  Assymetric encrytion using both a public key for others to use in encryting message, and a private key to decrypt messages.
    Public key is created by (e, n) where n is a large number and e is a number relatively prime to the function:
        (p-1)*(q-1)    where p and q are numbers that can be multiplied together to obtain n
    Private key is created by (d, n) where n is the same large number and d is a number that fulfills the requirement:
        e*d = 1(mod(p-1)*(q-1))
    Encryption function: C = P^e(mod n)   where P i the encrypted value, and C is the cipher text
    Decryption function: P = C^d(mod n)   where P i the encrypted value, and C is the cipher text
  
Hardware Efficiency for Exponents: More power is used up by each multiplication operation, so it is less efficient to write
   'x^19' which requires e-1 or 18 multiplications, than to refactor to '(x^16)(x^2)(x^1)' which is 3 operations. Use 
   powers of two when refactoring to make it easy to convert to binary, i.e. '10011' for above example
  
  Square and Multiply Algorithm: 
       Left-to-Right Implementation: To compute a^e (mod n)
                                        1.  Convert e to binary
                                        2.  b = 1
                                        3.  for (i=s;i>=0;i--)
                                        4.   { b=b*b (mod n);
                                                 if (binary of the current bit == 1)
                                                   b = b*a (mod n)
                                             }
                                             return b
                                             
        Right-to-Left Implementation: To compute a^e (mod n)
                                        1.  Convert e to binary
                                        2.  b= a to the power of the least significant bit, c = a         //b starts as a or 1
                                        3.  for (i=1;i>=s;i++)
                                        4.  { c=c*c (mod n);
                                                if (binary of the current bit == 1)
                                                  b=b*c (mod n)
                                            }
                                            return b
                                
  Square and Multiply is more efficent than writing an exponent, which needs exponent-1 multiplication operations. The 
    only multiplications done in Square and Multiply are when loop runs (once pet bit of exponent written in binary) and
    when the if statement runs (i.e. when it is 1 not 0). For example a^23 can be written using only 7 operations, not 22.
  Square and Multiply is vulnerable to side-channel attacks; possible to observe when if statements are ran based on
    increase in current, power or time delay, and thereby determine if a 1 or 0 is being processed.
    
  Montgomery Reduction: a method to optimize modular exponentiation
                             m = T(-N^-1)(mod R)
                             t = (T + mN)/R
                                if (N<=t)
                                  t=t-N
                                  
                            TR^-1 = (T + T(-N^-1) (mod R)N)/R (mod N)
                            
        Only conditions on R: R>N and R and N relatively prime. Efficiency gains can be made if you choose an R that is 
           R=2K or a power of two, because multiplication of R is a trivial shift to the left of K bits. Similarly, a division
           or modular R operation will be a shift to the right by k bits
                                            
Side Channel Attacks: Target implementation of crypto algorithm, not perfectly sound algorithm itself. It is also passive, 
  non-invasive, and mostly untraceable. Monitoring phase: measure chip's physical characteristics (power consumption, current,
  timing or delay, EM radiation or emission, acoustic information, optical information, output signals) during normal operation.
  Data Analysis phase follows. Side Channel Attacks can be used to improve active attacks (input control, fault injection)
  
Power/Current Side Channel: Dynamic Power (used to charge/discharge capacitors), Leakage Current (even if system idle), 
  Short Circuits. 
    Dynamic Leaks: The dynamic power consumption is based on switching activity (i.e. 0 to 1, 1 to 0) so if more power is 
      used it may leak information that bits are changing rather than staying in the same state(i.e. 0 to 0, 1 to 1)
  
  
Cache Memory:
Power Analysis: SPA, DPA
Timing Attacks:
Scan Chain Attacks:

                                       
                                       
                                   
  
    
  
    
      
  
  
  
    
  
  
    
  

  

  
